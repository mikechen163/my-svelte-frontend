import {
  extendTailwindMerge,
  twMerge
} from "./chunk-VUBVE77A.js";
import "./chunk-3F74YA3Z.js";

// node_modules/tailwind-variants/dist/chunk-I2QGXAA3.js
var l = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e;
var u = (e) => !e || typeof e != "object" || Object.keys(e).length === 0;
var x = (e, o) => JSON.stringify(e) === JSON.stringify(o);
function i(e, o) {
  e.forEach(function(r) {
    Array.isArray(r) ? i(r, o) : o.push(r);
  });
}
function y(e) {
  let o = [];
  return i(e, o), o;
}
var a = (...e) => y(e).filter(Boolean);
var p = (e, o) => {
  let r = {}, c = Object.keys(e), f = Object.keys(o);
  for (let t of c) if (f.includes(t)) {
    let s = e[t], n = o[t];
    Array.isArray(s) || Array.isArray(n) ? r[t] = a(n, s) : typeof s == "object" && typeof n == "object" ? r[t] = p(s, n) : r[t] = n + " " + s;
  } else r[t] = e[t];
  for (let t of f) c.includes(t) || (r[t] = o[t]);
  return r;
};
var g = (e) => !e || typeof e != "string" ? e : e.replace(/\s+/g, " ").trim();

// node_modules/tailwind-variants/dist/index.js
var ie = { twMerge: true, twMergeConfig: {}, responsiveVariants: false };
var x2 = (s) => s || void 0;
var N = (...s) => x2(y(s).filter(Boolean).join(" "));
var R = null;
var v = {};
var q = false;
var M = (...s) => (b$1) => b$1.twMerge ? ((!R || q) && (q = false, R = u(v) ? twMerge : extendTailwindMerge({ ...v, extend: { theme: v.theme, classGroups: v.classGroups, conflictingClassGroupModifiers: v.conflictingClassGroupModifiers, conflictingClassGroups: v.conflictingClassGroups, ...v.extend } })), x2(R(N(s)))) : N(s);
var _ = (s, b) => {
  for (let e in b) s.hasOwnProperty(e) ? s[e] = N(s[e], b[e]) : s[e] = b[e];
  return s;
};
var ce = (s, b$1) => {
  let { extend: e = null, slots: O = {}, variants: U = {}, compoundVariants: W = [], compoundSlots: C = [], defaultVariants: z = {} } = s, m = { ...ie, ...b$1 }, k = e != null && e.base ? N(e.base, s == null ? void 0 : s.base) : s == null ? void 0 : s.base, g$1 = e != null && e.variants && !u(e.variants) ? p(U, e.variants) : U, w = e != null && e.defaultVariants && !u(e.defaultVariants) ? { ...e.defaultVariants, ...z } : z;
  !u(m.twMergeConfig) && !x(m.twMergeConfig, v) && (q = true, v = m.twMergeConfig);
  let S = u(e == null ? void 0 : e.slots), T = u(O) ? {} : { base: N(s == null ? void 0 : s.base, S && (e == null ? void 0 : e.base)), ...O }, j = S ? T : _({ ...e == null ? void 0 : e.slots }, u(T) ? { base: s == null ? void 0 : s.base } : T), h$1 = u(e == null ? void 0 : e.compoundVariants) ? W : a(e == null ? void 0 : e.compoundVariants, W), V = (l2) => {
    if (u(g$1) && u(O) && S) return M(k, l2 == null ? void 0 : l2.class, l2 == null ? void 0 : l2.className)(m);
    if (h$1 && !Array.isArray(h$1)) throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof h$1}`);
    if (C && !Array.isArray(C)) throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof C}`);
    let P = (a2, n, t = [], i2) => {
      let r = t;
      if (typeof n == "string") r = r.concat(g(n).split(" ").map((o) => `${a2}:${o}`));
      else if (Array.isArray(n)) r = r.concat(n.reduce((o, c) => o.concat(`${a2}:${c}`), []));
      else if (typeof n == "object" && typeof i2 == "string") {
        for (let o in n) if (n.hasOwnProperty(o) && o === i2) {
          let c = n[o];
          if (c && typeof c == "string") {
            let u2 = g(c);
            r[i2] ? r[i2] = r[i2].concat(u2.split(" ").map((f) => `${a2}:${f}`)) : r[i2] = u2.split(" ").map((f) => `${a2}:${f}`);
          } else Array.isArray(c) && c.length > 0 && (r[i2] = c.reduce((u2, f) => u2.concat(`${a2}:${f}`), []));
        }
      }
      return r;
    }, D = (a$1, n = g$1, t = null, i2 = null) => {
      var L;
      let r = n[a$1];
      if (!r || u(r)) return null;
      let o = (L = i2 == null ? void 0 : i2[a$1]) != null ? L : l2 == null ? void 0 : l2[a$1];
      if (o === null) return null;
      let c = l(o), u2 = Array.isArray(m.responsiveVariants) && m.responsiveVariants.length > 0 || m.responsiveVariants === true, f = w == null ? void 0 : w[a$1], d = [];
      if (typeof c == "object" && u2) for (let [E, Q] of Object.entries(c)) {
        let ne = r[Q];
        if (E === "initial") {
          f = Q;
          continue;
        }
        Array.isArray(m.responsiveVariants) && !m.responsiveVariants.includes(E) || (d = P(E, ne, d, t));
      }
      let $ = c != null && typeof c != "object" ? c : l(f), A = r[$ || "false"];
      return typeof d == "object" && typeof t == "string" && d[t] ? _(d, A) : d.length > 0 ? (d.push(A), t === "base" ? d.join(" ") : d) : A;
    }, p2 = () => g$1 ? Object.keys(g$1).map((a2) => D(a2, g$1)) : null, ee = (a2, n) => {
      if (!g$1 || typeof g$1 != "object") return null;
      let t = new Array();
      for (let i2 in g$1) {
        let r = D(i2, g$1, a2, n), o = a2 === "base" && typeof r == "string" ? r : r && r[a2];
        o && (t[t.length] = o);
      }
      return t;
    }, H = {};
    for (let a2 in l2) l2[a2] !== void 0 && (H[a2] = l2[a2]);
    let I = (a2, n) => {
      var i2;
      let t = typeof (l2 == null ? void 0 : l2[a2]) == "object" ? { [a2]: (i2 = l2[a2]) == null ? void 0 : i2.initial } : {};
      return { ...w, ...H, ...t, ...n };
    }, J = (a2 = [], n) => {
      let t = [];
      for (let { class: i2, className: r, ...o } of a2) {
        let c = true;
        for (let [u2, f] of Object.entries(o)) {
          let d = I(u2, n)[u2];
          if (Array.isArray(f)) {
            if (!f.includes(d)) {
              c = false;
              break;
            }
          } else {
            let $ = (A) => A == null || A === false;
            if ($(f) && $(d)) continue;
            if (d !== f) {
              c = false;
              break;
            }
          }
        }
        c && (i2 && t.push(i2), r && t.push(r));
      }
      return t;
    }, te = (a2) => {
      let n = J(h$1, a2);
      if (!Array.isArray(n)) return n;
      let t = {};
      for (let i2 of n) if (typeof i2 == "string" && (t.base = M(t.base, i2)(m)), typeof i2 == "object") for (let [r, o] of Object.entries(i2)) t[r] = M(t[r], o)(m);
      return t;
    }, ae = (a2) => {
      if (C.length < 1) return null;
      let n = {};
      for (let { slots: t = [], class: i2, className: r, ...o } of C) {
        if (!u(o)) {
          let c = true;
          for (let u2 of Object.keys(o)) {
            let f = I(u2, a2)[u2];
            if (f === void 0 || (Array.isArray(o[u2]) ? !o[u2].includes(f) : o[u2] !== f)) {
              c = false;
              break;
            }
          }
          if (!c) continue;
        }
        for (let c of t) n[c] = n[c] || [], n[c].push([i2, r]);
      }
      return n;
    };
    if (!u(O) || !S) {
      let a2 = {};
      if (typeof j == "object" && !u(j)) for (let n of Object.keys(j)) a2[n] = (t) => {
        var i2, r;
        return M(j[n], ee(n, t), ((i2 = te(t)) != null ? i2 : [])[n], ((r = ae(t)) != null ? r : [])[n], t == null ? void 0 : t.class, t == null ? void 0 : t.className)(m);
      };
      return a2;
    }
    return M(k, p2(), J(h$1), l2 == null ? void 0 : l2.class, l2 == null ? void 0 : l2.className)(m);
  }, K = () => {
    if (!(!g$1 || typeof g$1 != "object")) return Object.keys(g$1);
  };
  return V.variantKeys = K(), V.extend = e, V.base = k, V.slots = j, V.variants = g$1, V.defaultVariants = w, V.compoundSlots = C, V.compoundVariants = h$1, V;
};
var fe = (s) => (b, e) => ce(b, e ? p(s, e) : s);
export {
  M as cn,
  N as cnBase,
  fe as createTV,
  ie as defaultConfig,
  ce as tv,
  x2 as voidEmpty
};
//# sourceMappingURL=tailwind-variants.js.map
